name: Coolify (cmux-server)

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  deployments: write

concurrency:
  group: coolify-cmux-server-${{ github.ref }}
  cancel-in-progress: false

jobs:
  report-deployment:
    name: Report deploy status
    runs-on: ubuntu-24.04
    timeout-minutes: 35
    env:
      RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
      ENVIRONMENT_NAME: Production â€“ cmux-server

    steps:
      - name: Create GitHub deployment
        id: gh_deployment
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const ref = context.sha;
            const runUrl = process.env.RUN_URL;
            const environment = process.env.ENVIRONMENT_NAME;

            const deployment = await github.rest.repos.createDeployment({
              owner,
              repo,
              ref,
              environment,
              auto_merge: false,
              required_contexts: [],
              description: `Coolify deploy for ${ref}`,
              transient_environment: false,
              production_environment: true,
            });

            core.setOutput("deployment_id", deployment.data.id);

            await github.rest.repos.createDeploymentStatus({
              owner,
              repo,
              deployment_id: deployment.data.id,
              state: "in_progress",
              log_url: runUrl,
              description: "Waiting for Coolify deployment",
            });

      - name: Wait for Coolify deployment
        id: coolify
        shell: bash
        env:
          COOLIFY_BASE_URL: ${{ secrets.COOLIFY_BASE_URL }}
          COOLIFY_API_TOKEN: ${{ secrets.COOLIFY_API_TOKEN }}
          COOLIFY_APP_UUID: ${{ secrets.COOLIFY_APP_UUID }}
          COOLIFY_ENV_URL: ${{ secrets.COOLIFY_ENV_URL }}
        run: |
          set -euo pipefail

          if [[ -z "${COOLIFY_BASE_URL:-}" ]]; then
            echo "Missing required secret: COOLIFY_BASE_URL" >&2
            exit 1
          fi
          if [[ -z "${COOLIFY_API_TOKEN:-}" ]]; then
            echo "Missing required secret: COOLIFY_API_TOKEN" >&2
            exit 1
          fi

          base_url="${COOLIFY_BASE_URL%/}"
          sha="${GITHUB_SHA}"
          sha7="${sha:0:7}"

          auth_header="Authorization: Bearer ${COOLIFY_API_TOKEN}"

          tmp_dir="$(mktemp -d)"
          trap 'rm -rf "$tmp_dir"' EXIT

          poll_interval_seconds=10
          find_timeout_seconds=$((5 * 60))
          deploy_timeout_seconds=$((30 * 60))

          now_epoch() { date +%s; }

          http_get_json() {
            local url="$1"
            local out_file="$2"
            local code
            code="$(curl -sS -o "$out_file" -w '%{http_code}' \
              --connect-timeout 10 --max-time 30 --retry 3 --retry-delay 1 \
              -H "Accept: application/json" -H "$auth_header" \
              "$url" || true)"
            echo "$code"
          }

          normalize_path() {
            local p="${1:-}"
            if [[ -z "$p" ]]; then
              echo ""
              return 0
            fi
            if [[ "$p" != /* ]]; then
              p="/$p"
            fi
            echo "${p%/}"
          }

          detect_app_uuid() {
            local apps_resp="$tmp_dir/apps.json"
            local code
            code="$(http_get_json "${base_url}/api/v1/applications" "$apps_resp")"
            if [[ "$code" != "200" ]]; then
              echo "" # signal failure
              return 0
            fi

            local base_dir
            base_dir="$(normalize_path "/apps/server")"

            # Prefer docker-compose location if it helps disambiguate; otherwise accept any match.
            local preferred_compose
            preferred_compose="$(normalize_path "/docker-compose.yml")"

            jq -r --arg base "$base_dir" --arg compose "$preferred_compose" '
              def norm_path($p):
                if ($p|type) != "string" or ($p|length)==0 then ""
                else ($p | if startswith("/") then . else "/" + . end | sub("/+$";""))
                end;

              [ .[]
                | { uuid: (.uuid // ""), base: norm_path(.base_directory), compose: norm_path(.docker_compose_location), name: (.name // "") }
                | select(.uuid != "" and .base == $base)
              ]
              | (if length == 1 then .[0]
                 else (map(select(.compose == $compose)) | if length == 1 then .[0] else empty end)
                 end)
              | (.uuid // empty)
            ' "$apps_resp" 2>/dev/null || true
          }

          auto_detected_app_uuid="$(detect_app_uuid || true)"
          app_uuid_source="secret"

          if [[ -z "${COOLIFY_APP_UUID:-}" ]]; then
            echo "COOLIFY_APP_UUID is not set; attempting auto-detection for base_directory=/apps/server..." >&2
            COOLIFY_APP_UUID="${auto_detected_app_uuid}"
            app_uuid_source="auto-detected"
            if [[ -z "${COOLIFY_APP_UUID:-}" ]]; then
              echo "Could not auto-detect COOLIFY_APP_UUID. Set the COOLIFY_APP_UUID secret (application UUID) or run: bash scripts/coolify-find-app-uuid.sh" >&2
              exit 1
            fi
            echo "Detected Coolify application UUID: ${COOLIFY_APP_UUID}" >&2
          fi

          echo "app_uuid_used=${COOLIFY_APP_UUID:-}" >> "$GITHUB_OUTPUT"
          echo "app_uuid_source=${app_uuid_source}" >> "$GITHUB_OUTPUT"

          find_deployment_uuid() {
            local start_epoch="$1"
            local deadline=$((start_epoch + find_timeout_seconds))
            local resp="$tmp_dir/resp.json"
            local dep_uuid
            local code
            local url

            while (( $(now_epoch) < deadline )); do
              for url in \
                "${base_url}/api/v1/deployments/applications/${COOLIFY_APP_UUID}?skip=0&take=20" \
                "${base_url}/api/v1/deployments/applications/${COOLIFY_APP_UUID}" \
                "${base_url}/api/v1/applications/${COOLIFY_APP_UUID}/deployments?skip=0&take=20" \
                "${base_url}/api/v1/applications/${COOLIFY_APP_UUID}/deployments" \
              ; do
                code="$(http_get_json "$url" "$resp")"
                if [[ "$code" == "200" ]]; then
                  dep_uuid="$(jq -r --arg sha "$sha" --arg sha7 "$sha7" '
                    def matches_commit($c):
                      ($c != null) and ($c != "") and
                      (($sha | startswith($c)) or ($c | startswith($sha)) or ($sha7 | startswith($c)) or ($c | startswith($sha7)));

                    (if type=="array" then .
                     elif has("data") and (.data|type)=="array" then .data
                     elif has("deployments") and (.deployments|type)=="array" then .deployments
                     else [] end)
                    | map(select(matches_commit(.commit) or matches_commit(.git_commit_sha) or matches_commit(.git_commit_hash)))
                    | (.[0] // empty)
                    | (.deployment_uuid // .uuid // empty)
                  ' "$resp" 2>/dev/null || true)"
                  if [[ -n "${dep_uuid:-}" && "${dep_uuid:-null}" != "null" ]]; then
                    echo "$dep_uuid"
                    return 0
                  fi
                fi
              done

              code="$(http_get_json "${base_url}/api/v1/deployments" "$resp")"
              if [[ "$code" == "200" ]]; then
                dep_uuid="$(jq -r --arg sha "$sha" --arg sha7 "$sha7" '
                  def matches_commit($c):
                    ($c != null) and ($c != "") and
                    (($sha | startswith($c)) or ($c | startswith($sha)) or ($sha7 | startswith($c)) or ($c | startswith($sha7)));

                  (if type=="array" then . else [] end)
                  | map(select(matches_commit(.commit) or matches_commit(.git_commit_sha) or matches_commit(.git_commit_hash)))
                  | (.[0] // empty)
                  | (.deployment_uuid // .uuid // empty)
                ' "$resp" 2>/dev/null || true)"
                if [[ -n "${dep_uuid:-}" && "${dep_uuid:-null}" != "null" ]]; then
                  echo "$dep_uuid"
                  return 0
                fi
              fi

              sleep "$poll_interval_seconds"
            done

            return 1
          }

          normalize_status() {
            local raw="$1"
            raw="$(echo "$raw" | tr '[:upper:]' '[:lower:]')"
            case "$raw" in
              success|succeeded|finished|completed) echo "success" ;;
              failed|failure|error|errored|cancelled|canceled) echo "failure" ;;
              running|queued|in_progress|in-progress|pending) echo "running" ;;
              *) echo "$raw" ;;
            esac
          }

          is_http_url() {
            local url="${1:-}"
            [[ "$url" =~ ^https?://[^[:space:]]+$ ]]
          }

          resolve_deployment_url() {
            local deployment_url_raw="${1:-}"
            if is_http_url "$deployment_url_raw"; then
              echo "$deployment_url_raw"
              return 0
            fi
            if is_http_url "${COOLIFY_ENV_URL:-}"; then
              echo "${COOLIFY_ENV_URL}"
              return 0
            fi
            if [[ -n "$deployment_url_raw" ]]; then
              echo "${base_url}/${deployment_url_raw#/}"
              return 0
            fi
            echo ""
          }

          debug_print_deployments() {
            local label="$1"
            local url="$2"
            local out_file="$3"
            local code

            code="$(http_get_json "$url" "$out_file")"
            echo "${label} (HTTP ${code})"
            echo "  endpoint: ${url}"
            if [[ "$code" != "200" ]]; then
              local snippet=""
              snippet="$(head -c 400 "$out_file" 2>/dev/null || true)"
              if [[ -n "${snippet:-}" ]]; then
                echo "  response snippet: ${snippet}"
              fi
              return 0
            fi

            jq -r --arg sha "$sha" --arg sha7 "$sha7" '
              def matches_commit($c):
                ($c != null) and ($c != "") and
                (($sha | startswith($c)) or ($c | startswith($sha)) or ($sha7 | startswith($c)) or ($c | startswith($sha7)));

              (if type=="array" then .
               elif has("data") and (.data|type)=="array" then .data
               elif has("deployments") and (.deployments|type)=="array" then .deployments
               else [] end)
              | .[0:10]
              | if length == 0 then
                  "  (no deployments returned)"
                else
                  .[]
                  | . as $dep
                  | ($dep.commit // $dep.git_commit_sha // $dep.git_commit_hash // "") as $commit
                  | "  - commit: \($commit | if . == \"\" then \"N/A\" else . end) | status: \($dep.status // \"unknown\") | uuid: \($dep.deployment_uuid // $dep.uuid // \"N/A\") | app: \($dep.application_uuid // \"N/A\") | match_sha: \(matches_commit($commit))"
                end
            ' "$out_file" 2>/dev/null || {
              echo "  (could not parse response as deployment list)"
              head -c 400 "$out_file" 2>/dev/null || true
              echo
            }
          }

          debug_no_deployment_found() {
            echo "::group::Debug: Coolify deployment lookup"
            echo "Deployment search details:"
            echo "  - target SHA: ${sha}"
            echo "  - target short SHA: ${sha7}"
            echo "  - app UUID source: ${app_uuid_source}"
            echo "  - app UUID used: ${COOLIFY_APP_UUID:-<empty>}"

            if [[ -f "$tmp_dir/apps.json" ]]; then
              echo "App detection candidates for base_directory=/apps/server:"
              jq -r '
                def norm_path($p):
                  if ($p|type) != "string" or ($p|length)==0 then ""
                  else ($p | if startswith("/") then . else "/" + . end | sub("/+$";""))
                  end;
                [ .[]
                  | { uuid: (.uuid // ""), name: (.name // "N/A"), base: norm_path(.base_directory), compose: norm_path(.docker_compose_location) }
                  | select(.base == "/apps/server")
                ][0:10]
                | if length == 0 then
                    "  (no app with base_directory=/apps/server found)"
                  else
                    .[] | "  - uuid: \(.uuid) | name: \(.name) | base: \(.base) | compose: \(.compose)"
                  end
              ' "$tmp_dir/apps.json" 2>/dev/null || echo "  (could not parse app detection response)"
            fi

            debug_print_deployments \
              "Recent deployments for app UUID" \
              "${base_url}/api/v1/applications/${COOLIFY_APP_UUID}/deployments?skip=0&take=10" \
              "$tmp_dir/debug_app_deployments.json"

            debug_print_deployments \
              "Recent deployments via deployments/applications endpoint" \
              "${base_url}/api/v1/deployments/applications/${COOLIFY_APP_UUID}?skip=0&take=10" \
              "$tmp_dir/debug_app_deployments_alt.json"

            debug_print_deployments \
              "Recent global deployments" \
              "${base_url}/api/v1/deployments?skip=0&take=10" \
              "$tmp_dir/debug_all_deployments.json"

            echo "::endgroup::"
          }

          echo "Looking for Coolify deployment for commit ${sha7}..." >&2
          start_epoch="$(now_epoch)"
          deployment_uuid="$(find_deployment_uuid "$start_epoch" || true)"

          if [[ -z "${deployment_uuid:-}" ]]; then
            debug_no_deployment_found
            echo "conclusion=failure" >> "$GITHUB_OUTPUT"
            echo "coolify_status=no_deployment_found" >> "$GITHUB_OUTPUT"
            deployment_url="$(resolve_deployment_url "")"
            echo "deployment_url=${deployment_url:-}" >> "$GITHUB_OUTPUT"
            echo "::error::No Coolify deployment found for SHA ${sha} (${sha7})"
            echo "This usually means one of the following:" >&2
            echo "  1. Coolify webhook did not trigger for this push." >&2
            echo "  2. Deployment is still pending/not yet created." >&2
            echo "  3. Commit SHA mismatch between GitHub and Coolify." >&2
            echo "App UUID used: ${COOLIFY_APP_UUID}" >&2
            echo "Endpoints checked:" >&2
            echo "  - ${base_url}/api/v1/deployments/applications/${COOLIFY_APP_UUID}" >&2
            echo "  - ${base_url}/api/v1/applications/${COOLIFY_APP_UUID}/deployments" >&2
            echo "  - ${base_url}/api/v1/deployments" >&2
            exit 1
          fi

          echo "Found Coolify deployment UUID: ${deployment_uuid}" >&2

          detail_url="${base_url}/api/v1/deployments/${deployment_uuid}"
          resp="$tmp_dir/detail.json"
          deadline=$((start_epoch + deploy_timeout_seconds))

          while (( $(now_epoch) < deadline )); do
            code="$(http_get_json "$detail_url" "$resp")"
            if [[ "$code" != "200" ]]; then
              echo "Coolify API returned HTTP ${code} for ${detail_url}, retrying..." >&2
              sleep "$poll_interval_seconds"
              continue
            fi

            raw_status="$(jq -r '.status // empty' "$resp" 2>/dev/null || true)"
            norm_status="$(normalize_status "${raw_status:-unknown}")"

            deployment_url_raw="$(jq -r '.deployment_url // empty' "$resp" 2>/dev/null || true)"
            deployment_url="$(resolve_deployment_url "${deployment_url_raw:-}")"

            echo "coolify_status=${raw_status:-unknown}" >> "$GITHUB_OUTPUT"
            echo "deployment_url=${deployment_url:-}" >> "$GITHUB_OUTPUT"

            if [[ "$norm_status" == "success" ]]; then
              echo "conclusion=success" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            if [[ "$norm_status" == "failure" ]]; then
              echo "conclusion=failure" >> "$GITHUB_OUTPUT"
              echo "Coolify deployment failed (status: ${raw_status})." >&2

              logs="$(jq -r '.logs // empty' "$resp" 2>/dev/null || true)"
              if [[ -n "${logs:-}" ]]; then
                echo "---- Coolify logs (tail) ----" >&2
                echo "$logs" | tail -n 200 >&2 || true
                echo "-----------------------------" >&2
              fi

              exit 1
            fi

            echo "Coolify deployment status: ${raw_status:-unknown} (waiting...)" >&2
            sleep "$poll_interval_seconds"
          done

          echo "conclusion=failure" >> "$GITHUB_OUTPUT"
          echo "coolify_status=timeout" >> "$GITHUB_OUTPUT"
          deployment_url="$(resolve_deployment_url "")"
          echo "deployment_url=${deployment_url:-}" >> "$GITHUB_OUTPUT"
          echo "Timed out waiting for Coolify deployment ${deployment_uuid}." >&2
          exit 1

      - name: Write debug summary on failure
        if: failure()
        shell: bash
        env:
          COOLIFY_BASE_URL: ${{ secrets.COOLIFY_BASE_URL }}
          COOLIFY_STATUS: ${{ steps.coolify.outputs.coolify_status }}
          COOLIFY_APP_UUID_USED: ${{ steps.coolify.outputs.app_uuid_used }}
          COOLIFY_APP_UUID_SOURCE: ${{ steps.coolify.outputs.app_uuid_source }}
        run: |
          set -euo pipefail

          base_url="${COOLIFY_BASE_URL%/}"
          coolify_status="${COOLIFY_STATUS:-unknown}"
          app_uuid_used="${COOLIFY_APP_UUID_USED:-unknown}"
          app_uuid_source="${COOLIFY_APP_UUID_SOURCE:-unknown}"

          cat >> "$GITHUB_STEP_SUMMARY" << EOF
          ## Coolify Deployment Status Check Failed

          **Commit:** \`${GITHUB_SHA}\`  
          **Run:** ${RUN_URL}  
          **Coolify status:** \`${coolify_status}\`  
          **App UUID used:** \`${app_uuid_used}\`  
          **App UUID source:** \`${app_uuid_source}\`

          ### Troubleshooting

          1. Check Coolify dashboard to confirm a deployment was created for this commit.
          2. Verify webhook and source settings for this Coolify application.
          3. Verify app matching locally: \`bash scripts/coolify-find-app-uuid.sh\`.

          ### API endpoints checked

          - \`${base_url}/api/v1/deployments/applications/${app_uuid_used}\`
          - \`${base_url}/api/v1/applications/${app_uuid_used}/deployments\`
          - \`${base_url}/api/v1/deployments\`

          ### Debug command

          \`\`\`bash
          curl -fsS "\$COOLIFY_BASE_URL/api/v1/deployments?skip=0&take=5" \\
            -H "Authorization: Bearer \$COOLIFY_API_TOKEN" | jq
          \`\`\`
          EOF

      - name: Update GitHub deployment status
        if: always()
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_ID: ${{ steps.gh_deployment.outputs.deployment_id }}
          CONCLUSION: ${{ steps.coolify.outputs.conclusion }}
          ENVIRONMENT_URL: ${{ steps.coolify.outputs.deployment_url }}
          COOLIFY_STATUS: ${{ steps.coolify.outputs.coolify_status }}
        with:
          script: |
            const deploymentIdRaw = process.env.DEPLOYMENT_ID;
            if (!deploymentIdRaw) {
              core.warning("No GitHub deployment id found. Skipping deployment status update.");
              return;
            }

            const { owner, repo } = context.repo;
            const deploymentId = Number(deploymentIdRaw);
            const runUrl = process.env.RUN_URL;
            const conclusion = process.env.CONCLUSION || "failure";
            const envUrlRaw = (process.env.ENVIRONMENT_URL || "").trim();
            const envUrl = /^https?:\/\/\S+$/i.test(envUrlRaw) ? envUrlRaw : undefined;
            const coolifyStatus = process.env.COOLIFY_STATUS || "unknown";
            if (envUrlRaw && !envUrl) {
              core.warning(`Ignoring invalid environment_url: ${envUrlRaw}`);
            }

            const state = conclusion === "success" ? "success" : "failure";
            const description =
              state === "success"
                ? "Coolify deployment succeeded"
                : `Coolify deployment failed (${coolifyStatus})`;

            const payload = {
              owner,
              repo,
              deployment_id: deploymentId,
              state,
              log_url: runUrl,
              description,
            };
            if (envUrl) {
              payload.environment_url = envUrl;
            }

            await github.rest.repos.createDeploymentStatus(payload);
