# Zod

Zod is a TypeScript-first schema validation library that enables you to define schemas for validating data, from simple strings to complex nested objects. It features zero external dependencies, works in Node.js and all modern browsers, and provides static type inference so your validated data is automatically typed. Zod 4 is the current stable version with major performance improvements (14x faster string parsing, 7x faster arrays, 6.5x faster objects) and a 2x reduction in core bundle size.

The library's immutable API means every method returns a new schema instance, making it safe to compose and reuse schemas. Key features include built-in JSON Schema conversion, first-party internationalization support with 40+ locales, and an extensive ecosystem of integrations including tRPC, React Hook Form, and many more. Zod also provides Zod Mini, a tree-shakable variant with a functional API that achieves 6.6x smaller bundle sizes for performance-critical applications.

## Installation

```bash
npm install zod
```

## Basic Schema Definition and Parsing

Define schemas to validate data and get strongly-typed results with automatic type inference.

```typescript
import * as z from "zod";

// Define a schema
const User = z.object({
  name: z.string(),
  email: z.email(),
  age: z.number().min(0).max(150),
  role: z.enum(["admin", "user", "guest"]),
});

// Infer TypeScript type from schema
type User = z.infer<typeof User>;
// { name: string; email: string; age: number; role: "admin" | "user" | "guest" }

// Parse and validate data - throws ZodError on failure
const validUser = User.parse({
  name: "Alice",
  email: "alice@example.com",
  age: 30,
  role: "admin",
});
// => { name: "Alice", email: "alice@example.com", age: 30, role: "admin" }

// Safe parsing - returns result object instead of throwing
const result = User.safeParse({ name: 123, email: "invalid" });
if (!result.success) {
  console.log(result.error.issues);
  // [
  //   { code: "invalid_type", expected: "string", path: ["name"], message: "..." },
  //   { code: "invalid_format", format: "email", path: ["email"], message: "..." },
  //   { code: "invalid_type", expected: "number", path: ["age"], message: "..." },
  //   { code: "invalid_value", path: ["role"], message: "..." }
  // ]
} else {
  console.log(result.data); // typed User
}
```

## Primitive Types

Validate primitive JavaScript types with built-in coercion support.

```typescript
import * as z from "zod";

// Basic primitives
z.string().parse("hello");        // => "hello"
z.number().parse(42);             // => 42
z.bigint().parse(100n);           // => 100n
z.boolean().parse(true);          // => true
z.null().parse(null);             // => null
z.undefined().parse(undefined);   // => undefined

// Coercion - convert input to target type
z.coerce.string().parse(42);      // => "42"
z.coerce.number().parse("42");    // => 42
z.coerce.boolean().parse(1);      // => true
z.coerce.bigint().parse("100");   // => 100n
z.coerce.date().parse("2024-01-01"); // => Date object

// Literals
z.literal("hello").parse("hello"); // => "hello"
z.literal(42).parse(42);           // => 42
z.literal(["a", "b", "c"]).parse("b"); // => "b" (multiple literals)

// Any and unknown
z.any().parse(anything);           // allows anything
z.unknown().parse(anything);       // allows anything, typed as unknown
```

## String Validation

Comprehensive string validation including length constraints, patterns, and built-in formats.

```typescript
import * as z from "zod";

// String constraints
const username = z.string()
  .min(3, "Username must be at least 3 characters")
  .max(20, "Username must be at most 20 characters")
  .regex(/^[a-zA-Z0-9_]+$/, "Only alphanumeric characters and underscores");

username.parse("valid_user");  // => "valid_user"
username.parse("ab");          // throws: "Username must be at least 3 characters"

// String transformations
z.string().trim().parse("  hello  ");           // => "hello"
z.string().toLowerCase().parse("HELLO");        // => "hello"
z.string().toUpperCase().parse("hello");        // => "HELLO"

// Built-in string formats (top-level functions in Zod 4)
z.email().parse("user@example.com");            // validates email
z.uuid().parse("550e8400-e29b-41d4-a716-446655440000");
z.uuidv4().parse("...");                        // specific UUID version
z.url().parse("https://example.com");
z.ipv4().parse("192.168.1.1");
z.ipv6().parse("::1");
z.base64().parse("SGVsbG8gV29ybGQ=");
z.jwt().parse("eyJhbGciOiJIUzI1NiIs...");

// ISO date/time formats
z.iso.date().parse("2024-01-15");               // YYYY-MM-DD
z.iso.time().parse("14:30:00");                 // HH:MM:SS
z.iso.datetime().parse("2024-01-15T14:30:00Z"); // ISO 8601
z.iso.datetime({ offset: true }).parse("2024-01-15T14:30:00+05:00");

// Custom email regex patterns
z.email({ pattern: z.regexes.html5Email });     // browser-style validation
z.email({ pattern: z.regexes.rfc5322Email });   // RFC 5322 compliant
z.email({ pattern: z.regexes.unicodeEmail });   // international emails
```

## Number Validation

Number validation with range constraints, integer types, and numeric formats.

```typescript
import * as z from "zod";

// Number constraints
const age = z.number()
  .min(0, "Age cannot be negative")
  .max(150, "Age seems unrealistic")
  .int("Age must be a whole number");

age.parse(25);    // => 25
age.parse(-5);    // throws: "Age cannot be negative"
age.parse(25.5);  // throws: "Age must be a whole number"

// Number comparisons
z.number().gt(5).parse(10);       // greater than 5
z.number().gte(5).parse(5);       // greater than or equal (alias: .min())
z.number().lt(10).parse(5);       // less than 10
z.number().lte(10).parse(10);     // less than or equal (alias: .max())
z.number().positive().parse(1);   // > 0
z.number().negative().parse(-1);  // < 0
z.number().nonnegative().parse(0); // >= 0
z.number().multipleOf(5).parse(15); // divisible by 5

// Integer types with safe ranges
z.int().parse(42);                // safe integer range
z.int32().parse(2147483647);      // 32-bit signed integer
z.uint32().parse(4294967295);     // 32-bit unsigned integer

// Floating point types
z.float32().parse(3.14);          // 32-bit float range
z.float64().parse(1.7976931348623157e308); // 64-bit float range

// BigInt
z.bigint().parse(9007199254740991n);
z.int64().parse(9223372036854775807n);   // 64-bit signed
z.uint64().parse(18446744073709551615n); // 64-bit unsigned
```

## Objects

Define object schemas with optional fields, strict/loose modes, and object manipulation methods.

```typescript
import * as z from "zod";

// Basic object schema - strips unknown keys by default
const Person = z.object({
  name: z.string(),
  age: z.number().optional(),  // optional field
  email: z.email(),
});

Person.parse({ name: "Alice", email: "a@b.com", extra: "ignored" });
// => { name: "Alice", email: "a@b.com" } - extra key stripped

// Strict object - throws on unknown keys
const StrictPerson = z.strictObject({
  name: z.string(),
  email: z.email(),
});
StrictPerson.parse({ name: "Alice", email: "a@b.com", extra: "oops" });
// throws: Unrecognized key: "extra"

// Loose object - passes through unknown keys
const LoosePerson = z.looseObject({
  name: z.string(),
});
LoosePerson.parse({ name: "Alice", extra: "kept" });
// => { name: "Alice", extra: "kept" }

// Catchall for unknown keys
const WithCatchall = z.object({ id: z.number() }).catchall(z.string());
WithCatchall.parse({ id: 1, foo: "bar", baz: "qux" }); // all extra keys must be strings

// Object manipulation
const User = z.object({
  id: z.number(),
  name: z.string(),
  email: z.email(),
  password: z.string(),
});

// Pick specific keys
const PublicUser = User.pick({ id: true, name: true });
// { id: number; name: string }

// Omit specific keys
const UserWithoutPassword = User.omit({ password: true });
// { id: number; name: string; email: string }

// Make all fields optional
const PartialUser = User.partial();
// { id?: number; name?: string; email?: string; password?: string }

// Make specific fields optional
const UserOptionalEmail = User.partial({ email: true });

// Make all fields required
const RequiredUser = PartialUser.required();

// Extend an object
const UserWithRole = User.extend({ role: z.enum(["admin", "user"]) });

// Access shape
User.shape.name;  // => ZodString
User.keyof();     // => ZodEnum<["id", "name", "email", "password"]>
```

## Arrays and Tuples

Validate arrays and fixed-length tuples with element type checking.

```typescript
import * as z from "zod";

// Array of strings
const tags = z.array(z.string());
tags.parse(["typescript", "zod", "validation"]); // => ["typescript", "zod", "validation"]

// Array constraints
const nonEmptyTags = z.array(z.string())
  .min(1, "At least one tag required")
  .max(10, "Maximum 10 tags allowed")
  .length(5); // exactly 5 items

// Access element type
tags.unwrap(); // => ZodString

// Tuples - fixed length with specific types per position
const coordinate = z.tuple([z.number(), z.number()]);
coordinate.parse([10, 20]); // => [10, 20]
coordinate.parse([10, 20, 30]); // throws: too many items

// Tuple with rest element
const atLeastTwoNumbers = z.tuple([z.number(), z.number()], z.number());
// [number, number, ...number[]]
atLeastTwoNumbers.parse([1, 2]);       // => [1, 2]
atLeastTwoNumbers.parse([1, 2, 3, 4]); // => [1, 2, 3, 4]

// Mixed type tuple
const mixedTuple = z.tuple([z.string(), z.number(), z.boolean()]);
mixedTuple.parse(["hello", 42, true]); // => ["hello", 42, true]
```

## Unions and Discriminated Unions

Create union types for values that can be one of several types.

```typescript
import * as z from "zod";

// Simple union
const stringOrNumber = z.union([z.string(), z.number()]);
stringOrNumber.parse("hello"); // => "hello"
stringOrNumber.parse(42);      // => 42
stringOrNumber.parse(true);    // throws

// Discriminated union - more efficient for object unions
const Result = z.discriminatedUnion("status", [
  z.object({ status: z.literal("success"), data: z.string() }),
  z.object({ status: z.literal("error"), error: z.string(), code: z.number() }),
]);

Result.parse({ status: "success", data: "Hello!" });
// => { status: "success", data: "Hello!" }

Result.parse({ status: "error", error: "Not found", code: 404 });
// => { status: "error", error: "Not found", code: 404 }

// Nested discriminated unions
const ApiResponse = z.discriminatedUnion("type", [
  z.object({ type: z.literal("user"), user: z.object({ name: z.string() }) }),
  z.discriminatedUnion("errorType", [
    z.object({ type: z.literal("error"), errorType: z.literal("validation"), fields: z.array(z.string()) }),
    z.object({ type: z.literal("error"), errorType: z.literal("server"), message: z.string() }),
  ]),
]);

// Exclusive union (XOR) - exactly one must match
const exclusiveUnion = z.xor([
  z.object({ type: z.literal("a"), value: z.string() }),
  z.object({ type: z.literal("b"), count: z.number() }),
]);
```

## Enums

Define enums from string arrays or TypeScript enums.

```typescript
import * as z from "zod";

// String enum
const Status = z.enum(["pending", "active", "archived"]);
type Status = z.infer<typeof Status>; // "pending" | "active" | "archived"

Status.parse("active");  // => "active"
Status.parse("invalid"); // throws

// Access enum values
Status.enum;             // { pending: "pending", active: "active", archived: "archived" }
Status.options;          // ["pending", "active", "archived"]

// Extract/exclude values
const ActiveOrArchived = Status.extract(["active", "archived"]);
const NotArchived = Status.exclude(["archived"]);

// From const array
const ROLES = ["admin", "user", "guest"] as const;
const Role = z.enum(ROLES);

// Numeric enum (object-style)
const Priority = z.enum({
  Low: 0,
  Medium: 1,
  High: 2,
} as const);

Priority.parse(0);         // => 0
Priority.parse("High");    // throws (use value, not key)

// TypeScript enum support
enum Color {
  Red = "red",
  Green = "green",
  Blue = "blue",
}
const ColorSchema = z.enum(Color);
ColorSchema.parse(Color.Red); // => "red"
```

## Optional, Nullable, and Default Values

Handle optional values, nullability, and default values.

```typescript
import * as z from "zod";

// Optional - allows undefined
const optionalString = z.optional(z.string());
// or: z.string().optional()
optionalString.parse("hello");    // => "hello"
optionalString.parse(undefined);  // => undefined

// Nullable - allows null
const nullableString = z.nullable(z.string());
// or: z.string().nullable()
nullableString.parse("hello"); // => "hello"
nullableString.parse(null);    // => null

// Nullish - allows both null and undefined
const nullishString = z.nullish(z.string());
nullishString.parse("hello");    // => "hello"
nullishString.parse(null);       // => null
nullishString.parse(undefined);  // => undefined

// Default values
const withDefault = z.string().default("anonymous");
withDefault.parse("Alice");     // => "Alice"
withDefault.parse(undefined);   // => "anonymous"

// Dynamic default
const withDynamicDefault = z.number().default(() => Math.random());
withDynamicDefault.parse(undefined); // => 0.7234...

// Catch - fallback on validation error
const withCatch = z.number().catch(0);
withCatch.parse(42);       // => 42
withCatch.parse("invalid"); // => 0 (fallback)

// Prefault - pre-parse default (runs through transforms)
const trimmedDefault = z.string().trim().prefault("  untrimmed  ");
trimmedDefault.parse(undefined); // => "untrimmed" (trimmed!)
```

## Refinements and Custom Validation

Add custom validation logic with refinements and superRefine.

```typescript
import * as z from "zod";

// Simple refinement
const positiveNumber = z.number().refine(
  (n) => n > 0,
  { message: "Must be positive" }
);

positiveNumber.parse(5);   // => 5
positiveNumber.parse(-1);  // throws: "Must be positive"

// Refinement with custom path (for objects)
const passwordForm = z.object({
  password: z.string().min(8),
  confirmPassword: z.string(),
}).refine(
  (data) => data.password === data.confirmPassword,
  {
    message: "Passwords don't match",
    path: ["confirmPassword"], // error appears on this field
  }
);

// Async refinement
const uniqueEmail = z.email().refine(
  async (email) => {
    const exists = await checkEmailExists(email);
    return !exists;
  },
  { message: "Email already registered" }
);
// Must use parseAsync for async refinements
await uniqueEmail.parseAsync("new@example.com");

// superRefine for multiple issues
const complexValidation = z.array(z.string()).superRefine((val, ctx) => {
  if (val.length > 10) {
    ctx.addIssue({
      code: "too_big",
      maximum: 10,
      origin: "array",
      inclusive: true,
      message: "Too many items",
      input: val,
    });
  }

  const duplicates = val.filter((item, i) => val.indexOf(item) !== i);
  if (duplicates.length > 0) {
    ctx.addIssue({
      code: "custom",
      message: `Duplicate values: ${duplicates.join(", ")}`,
      input: val,
    });
  }
});
```

## Transforms and Pipes

Transform parsed data and chain schemas together.

```typescript
import * as z from "zod";

// Basic transform
const stringToLength = z.string().transform((s) => s.length);
stringToLength.parse("hello"); // => 5

// Transform with validation context
const safeParseInt = z.string().transform((val, ctx) => {
  const parsed = parseInt(val, 10);
  if (isNaN(parsed)) {
    ctx.issues.push({
      code: "custom",
      message: "Not a valid integer",
      input: val,
    });
    return z.NEVER; // exit without affecting return type
  }
  return parsed;
});

// Pipes - chain schemas together
const stringToNumber = z.string()
  .pipe(z.transform((s) => parseInt(s, 10)))
  .pipe(z.number().min(0));

stringToNumber.parse("42");   // => 42
stringToNumber.parse("-5");   // throws: must be >= 0
stringToNumber.parse("abc");  // throws: NaN is not a number

// Preprocess - transform before validation
const trimmedString = z.preprocess(
  (val) => typeof val === "string" ? val.trim() : val,
  z.string().min(1)
);
trimmedString.parse("  hello  "); // => "hello"

// Coerce + transform combo
const dateFromString = z.coerce.date()
  .transform((date) => date.toISOString());
dateFromString.parse("2024-01-15"); // => "2024-01-15T00:00:00.000Z"
```

## Records and Maps

Validate dictionary-like structures with dynamic keys.

```typescript
import * as z from "zod";

// Record with string keys
const stringRecord = z.record(z.string(), z.number());
stringRecord.parse({ a: 1, b: 2, c: 3 }); // => { a: 1, b: 2, c: 3 }

// Record with enum keys (exhaustive)
const StatusCounts = z.record(
  z.enum(["pending", "active", "archived"]),
  z.number()
);
StatusCounts.parse({ pending: 5, active: 10, archived: 2 }); // all keys required

// Partial record - not all keys required
const PartialStatusCounts = z.partialRecord(
  z.enum(["pending", "active", "archived"]),
  z.number()
);
PartialStatusCounts.parse({ pending: 5 }); // OK, missing keys allowed

// Loose record - unknown keys pass through
const looseRecord = z.looseRecord(z.string().regex(/^id_/), z.number());
// Only validates keys matching pattern

// Map validation
const userMap = z.map(z.string(), z.object({ name: z.string() }));
const map = new Map([["user1", { name: "Alice" }]]);
userMap.parse(map); // => Map { "user1" => { name: "Alice" } }

// Set validation
const tagSet = z.set(z.string()).min(1).max(10);
tagSet.parse(new Set(["a", "b", "c"])); // => Set { "a", "b", "c" }
```

## Recursive Types

Define self-referential and mutually recursive schemas.

```typescript
import * as z from "zod";

// Self-referential type using getter
const Category = z.object({
  name: z.string(),
  get subcategories() {
    return z.array(Category);
  },
});

type Category = z.infer<typeof Category>;
// { name: string; subcategories: Category[] }

Category.parse({
  name: "Electronics",
  subcategories: [
    { name: "Phones", subcategories: [] },
    { name: "Computers", subcategories: [
      { name: "Laptops", subcategories: [] }
    ]}
  ]
});

// Mutually recursive types
const User = z.object({
  name: z.string(),
  get posts() {
    return z.array(Post);
  },
});

const Post = z.object({
  title: z.string(),
  get author() {
    return User;
  },
});

// JSON type (recursive by nature)
const JsonValue = z.json();
JsonValue.parse({ nested: { array: [1, "two", true, null] } });
```

## Error Handling and Customization

Customize error messages and handle validation errors.

```typescript
import * as z from "zod";

// Inline error messages
z.string("Expected a string");
z.string().min(5, "Too short!");
z.string().min(5, { error: "Minimum 5 characters required" });

// Dynamic error messages
z.string({
  error: (issue) => issue.input === undefined
    ? "This field is required"
    : "Invalid input"
});

// Per-parse error customization
const schema = z.string().min(5);
schema.parse("hi", {
  error: (issue) => {
    if (issue.code === "too_small") {
      return `Need at least ${issue.minimum} characters`;
    }
    return undefined; // use default message
  }
});

// Global error customization
z.config({
  customError: (issue) => {
    if (issue.code === "invalid_type") {
      return `Expected ${issue.expected}, got ${typeof issue.input}`;
    }
  }
});

// Internationalization
import { fr } from "zod/locales";
z.config(fr()); // French error messages

// Pretty print errors
const result = z.object({ name: z.string() }).safeParse({ name: 123 });
if (!result.success) {
  console.log(z.prettifyError(result.error));
  // ✖ Invalid input: expected string, received number
  //   → at name
}

// Include input in issues (opt-in for security)
z.string().parse(123, { reportInput: true });
// Issue includes: input: 123
```

## JSON Schema Conversion

Convert Zod schemas to and from JSON Schema.

```typescript
import * as z from "zod";

// Convert Zod to JSON Schema
const User = z.object({
  name: z.string().meta({ description: "User's full name" }),
  email: z.email(),
  age: z.number().int().min(0).max(150),
});

const jsonSchema = z.toJSONSchema(User);
// {
//   type: "object",
//   properties: {
//     name: { type: "string", description: "User's full name" },
//     email: { type: "string", format: "email" },
//     age: { type: "integer", minimum: 0, maximum: 150 }
//   },
//   required: ["name", "email", "age"],
//   additionalProperties: false
// }

// Options for JSON Schema conversion
z.toJSONSchema(User, {
  target: "openapi-3.0",      // or "draft-07", "draft-2020-12"
  io: "input",               // "input" or "output" type
  unrepresentable: "any",    // handle unsupported types
  cycles: "ref",             // handle recursive schemas
  reused: "ref",             // extract repeated schemas to $defs
});

// Convert JSON Schema to Zod (experimental)
const zodSchema = z.fromJSONSchema({
  type: "object",
  properties: {
    name: { type: "string" },
    count: { type: "integer", minimum: 0 }
  },
  required: ["name"]
});
```

## Metadata and Registries

Attach metadata to schemas for documentation and code generation.

```typescript
import * as z from "zod";

// Add metadata with .meta()
const Email = z.email().meta({
  id: "user_email",
  title: "Email Address",
  description: "A valid email address",
  examples: ["user@example.com"],
});

// Retrieve metadata
Email.meta(); // => { id: "user_email", title: "Email Address", ... }

// Custom registry with typed metadata
const formRegistry = z.registry<{
  label: string;
  placeholder?: string;
  helpText?: string;
}>();

const nameField = z.string()
  .min(1)
  .register(formRegistry, {
    label: "Full Name",
    placeholder: "Enter your name",
    helpText: "As it appears on your ID",
  });

// Retrieve from registry
formRegistry.get(nameField); // => { label: "Full Name", ... }

// Registry with constrained schema types
const stringRegistry = z.registry<{ pattern: string }, z.ZodString>();
stringRegistry.add(z.string(), { pattern: "text" }); // OK
stringRegistry.add(z.number(), { pattern: "num" });  // Type error!

// Global registry for JSON Schema metadata
z.globalRegistry.add(Email, {
  id: "email",
  title: "Email",
  description: "Contact email",
});
```

## Branded Types

Create nominal types for type-safe domain modeling.

```typescript
import * as z from "zod";

// Branded user ID
const UserId = z.string().uuid().brand<"UserId">();
type UserId = z.infer<typeof UserId>;
// string & z.$brand<"UserId">

const userId = UserId.parse("550e8400-e29b-41d4-a716-446655440000");

// Cannot accidentally mix branded types
const OrderId = z.string().uuid().brand<"OrderId">();
type OrderId = z.infer<typeof OrderId>;

function getUser(id: UserId) { /* ... */ }
const orderId = OrderId.parse("...");
getUser(orderId); // Type error! OrderId is not assignable to UserId

// Brand direction control
z.string().brand<"Token", "out">();   // output branded (default)
z.string().brand<"Token", "in">();    // input branded
z.string().brand<"Token", "inout">(); // both branded
```

## Codecs (Bidirectional Transforms)

Define reversible transformations between types.

```typescript
import * as z from "zod";

// Define a codec for string <-> Date conversion
const dateCodec = z.codec(
  z.iso.datetime(),  // input schema
  z.date(),          // output schema
  {
    decode: (str) => new Date(str),    // string -> Date
    encode: (date) => date.toISOString(), // Date -> string
  }
);

// Decode (parse): string -> Date
const date = dateCodec.parse("2024-01-15T10:30:00.000Z");
// => Date object

// Also available as z.decode()
z.decode(dateCodec, "2024-01-15T10:30:00.000Z"); // => Date

// Encode: Date -> string
z.encode(dateCodec, new Date("2024-01-15"));
// => "2024-01-15T00:00:00.000Z"

// Number to string codec
const numberCodec = z.codec(
  z.string().regex(/^\d+$/),
  z.number().int(),
  {
    decode: (s) => parseInt(s, 10),
    encode: (n) => n.toString(),
  }
);

z.decode(numberCodec, "42");  // => 42
z.encode(numberCodec, 42);    // => "42"
```

## Functions Schema

Define and implement validated functions.

```typescript
import * as z from "zod";

// Define function signature
const addNumbers = z.function({
  input: [z.number(), z.number()],
  output: z.number(),
});

type AddNumbers = z.infer<typeof addNumbers>;
// (arg0: number, arg1: number) => number

// Implement with automatic validation
const add = addNumbers.implement((a, b) => a + b);

add(2, 3);        // => 5
add("2", 3);      // throws: invalid input type
add(2, 3).toFixed(); // TypeScript knows result is number

// Async function
const fetchUser = z.function({
  input: [z.string().uuid()],
  output: z.object({ id: z.string(), name: z.string() }),
});

const getUser = fetchUser.implementAsync(async (id) => {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
});

// Input-only validation (no output check)
const logMessage = z.function({
  input: [z.string()],
}).implement((msg) => {
  console.log(msg);
  return undefined; // return type is inferred
});
```

## Zod Mini (Tree-Shakable API)

Use Zod Mini for minimal bundle sizes with a functional API.

```typescript
import * as z from "zod/mini";

// Functional API instead of methods
const User = z.object({
  name: z.string(),
  age: z.optional(z.number()),
  tags: z.array(z.string()),
});

// Checks use wrapper functions
const validatedString = z.string().check(
  z.minLength(5),
  z.maxLength(100),
  z.refine((s) => s.includes("@")),
);

// Parsing works the same
User.parse({ name: "Alice", tags: ["admin"] });
User.safeParse({ name: 123 });

// Object operations are functions
const PartialUser = z.partial(User);
const PickedUser = z.pick(User, { name: true });
const ExtendedUser = z.extend(User, { role: z.string() });

// Metadata via check
const email = z.email().check(
  z.meta({ description: "User email" })
);

// Core bundle size: ~1.88kb gzipped (vs ~5.36kb for regular Zod)
```

## Summary

Zod is a comprehensive TypeScript-first validation library that provides type-safe schema definitions with automatic type inference. Its primary use cases include API input validation, form validation, configuration parsing, and data transformation pipelines. The library excels at runtime type checking while maintaining full TypeScript integration, ensuring your validated data matches your type definitions.

Key integration patterns include combining Zod with API frameworks like tRPC for end-to-end type safety, using the JSON Schema conversion for OpenAPI documentation and AI structured outputs, and leveraging registries for metadata management in code generation tools. For performance-critical applications, Zod Mini offers a tree-shakable alternative with significantly smaller bundle sizes. The extensive locale support and customizable error handling make Zod suitable for international applications with complex validation requirements.
